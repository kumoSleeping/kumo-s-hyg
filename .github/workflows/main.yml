name: Build and Release Multi-Platform

on:
  push:
    branches:
      - main

env:
  APP_NAME: khyg
  # Version number will be dynamically set in the Extract version step

jobs:
  build-windows:
    runs-on: windows-latest
    permissions:
      contents: write # Needed to upload artifacts

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Fetch all history for version extraction/tagging
        fetch-tags: true

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyinstaller
      shell: pwsh # Use PowerShell

    - name: Extract version from __init__.py
      id: get_version
      run: |
        $VERSION_STR = python app/__init__.py -v
        if (-not $VERSION_STR) {
          Write-Error "Failed to extract version from app/__init__.py -v"
          exit 1
        }
        # Set environment variables for subsequent steps in this job and for create-release job needs
        echo "VERSION=$VERSION_STR" >> $env:GITHUB_ENV # Use PowerShell syntax for Windows runner
        echo "OUTPUT_NAME=${{ env.APP_NAME }}-windows-v$VERSION_STR" >> $env:GITHUB_ENV # Use PowerShell syntax
        Write-Host "Extracted Version: $VERSION_STR"
        Write-Host "Set OUTPUT_NAME to: ${{ env.APP_NAME }}-windows-v$VERSION_STR"
      shell: pwsh # Use PowerShell

    - name: Verify Environment Variables # Added verification step
      run: |
        Write-Host "VERSION is: ${{ env.VERSION }}"
        Write-Host "OUTPUT_NAME is: ${{ env.OUTPUT_NAME }}"
        if (-not $env:OUTPUT_NAME) {
          Write-Error "OUTPUT_NAME environment variable is not set or is empty after extraction!"
          exit 1
        }
      shell: pwsh

    - name: Build Windows EXE
      run: |
        pyinstaller --onefile --name "${{ env.OUTPUT_NAME }}" --hidden-import noneprompt --hidden-import PyYAML --hidden-import requests --hidden-import qrcode --hidden-import loguru --hidden-import PIL --add-data "app;app" run.py
        # Redundant mv command removed
      shell: pwsh # Use PowerShell

    - name: Upload Windows Artifact
      uses: actions/upload-artifact@v4
      with:
        name: windows-executable
        path: dist/${{ env.OUTPUT_NAME }}.exe # Path to the executable created by PyInstaller

  build-macos:
    runs-on: macos-latest
    permissions:
      contents: write # Needed to upload artifacts

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyinstaller

    - name: Extract version from __init__.py
      id: get_version
      run: |
        VERSION_STR=$(python app/__init__.py -v)
        if [ -z "$VERSION_STR" ]; then
          echo "::error::Failed to extract version from app/__init__.py -v"
          exit 1
        fi
        # Set environment variables for subsequent steps in this job and for create-release job needs
        echo "VERSION=$VERSION_STR" >> $GITHUB_ENV # Use Bash syntax for macOS runner
        echo "OUTPUT_NAME=${{ env.APP_NAME }}-macos-v$VERSION_STR" >> $GITHUB_ENV # Use Bash syntax
        echo "Extracted Version: $VERSION_STR"
        echo "Set OUTPUT_NAME to: ${{ env.APP_NAME }}-macos-v$VERSION_STR"

    - name: Verify Environment Variables
      run: |
        echo "VERSION is: ${{ env.VERSION }}"
        echo "OUTPUT_NAME is: ${{ env.OUTPUT_NAME }}"
        if [ -z "${{ env.OUTPUT_NAME }}" ]; then
           echo "::error::OUTPUT_NAME environment variable is not set or is empty after extraction!"
           exit 1
        fi

    - name: Build macOS App
      run: |
        pyinstaller --onefile --name "${{ env.OUTPUT_NAME }}" --hidden-import noneprompt --hidden-import PyYAML --hidden-import requests --hidden-import qrcode --hidden-import loguru --hidden-import PIL --add-data "app:app" run.py
        # Ensure the output file is executable
        chmod +x dist/"${{ env.OUTPUT_NAME }}"

    - name: Upload macOS Artifact
      uses: actions/upload-artifact@v4
      with:
        name: macos-executable
        path: dist/${{ env.OUTPUT_NAME }} # Path to the executable created by PyInstaller

  create-release:
    needs: [build-windows, build-macos] # Run after both builds succeed
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to create tags and releases

    steps:
      # Need checkout to run python script again or to tag
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      # Re-extract version here to be certain it's available for release naming/tagging
      - name: Extract version for Release
        id: get_version_release
        run: |
          VERSION_STR=$(python app/__init__.py -v)
          if [ -z "$VERSION_STR" ]; then
            echo "::error::Failed to extract version from app/__init__.py -v for release"
            exit 1
          fi
          echo "VERSION=$VERSION_STR" >> $GITHUB_ENV
          echo "WINDOWS_FILENAME=${{ env.APP_NAME }}-windows-v$VERSION_STR.exe" >> $GITHUB_ENV
          echo "MACOS_FILENAME=${{ env.APP_NAME }}-macos-v$VERSION_STR" >> $GITHUB_ENV
          echo "Release Version: $VERSION_STR"

      - name: Download Windows Artifact
        uses: actions/download-artifact@v4
        with:
          name: windows-executable
          path: artifacts # Download all artifacts to a common directory

      - name: Download macOS Artifact
        uses: actions/download-artifact@v4
        with:
          name: macos-executable
          path: artifacts # Download all artifacts to a common directory

      # Verify downloaded files exist before proceeding
      - name: Verify Downloaded Artifacts
        run: |
          echo "Checking for Windows artifact: artifacts/${{ env.WINDOWS_FILENAME }}"
          ls -l artifacts/
          if [ ! -f "artifacts/${{ env.WINDOWS_FILENAME }}" ]; then
            echo "::error::Windows artifact not found after download!"
            exit 1
          fi
          echo "Checking for macOS artifact: artifacts/${{ env.MACOS_FILENAME }}"
          if [ ! -f "artifacts/${{ env.MACOS_FILENAME }}" ]; then
            echo "::error::macOS artifact not found after download!"
            exit 1
          fi

      - name: Check if Release Exists
        id: check_release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const tag_name = "v${{ env.VERSION }}";
            try {
              const release = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tag_name });
              console.log(`Release ${tag_name} already exists.`);
              return { release_exists: true }; // Output is set here
            } catch (error) {
              if (error.status === 404) {
                console.log(`Release ${tag_name} does not exist yet.`);
                return { release_exists: false }; // Output is set here
              } else {
                console.error(`Error checking release: ${error.message}`);
                throw error;
              }
            }
        # Invalid 'outputs:' block removed from here

      - name: Create Release
        # Use fromJson() to correctly parse the JSON string output from github-script
        if: fromJson(steps.check_release.outputs.result).release_exists == false
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.VERSION }}
          name: Release v${{ env.VERSION }}
          body: |
            Automated release for version ${{ env.VERSION }}.

            **Downloads:**
            * Windows: `${{ env.WINDOWS_FILENAME }}`
            * macOS: `${{ env.MACOS_FILENAME }}`
          draft: false
          prerelease: false
          files: |
            artifacts/${{ env.WINDOWS_FILENAME }}
            artifacts/${{ env.MACOS_FILENAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
